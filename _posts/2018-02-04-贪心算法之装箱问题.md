---
layout: post
title: 浅谈算法--贪心算法之装箱问题
date: 2018-02-04
tag: 博客 
---   

## 写在前面：

　　读者有什么问题可以加我 ＱＱ：995107866　，或者给我发邮件：[995107866@qq.com](mailto:995107866@qq.com)，望不吝赐教。

　　贪心算法，亦可称为贪婪算法，在贪婪算法中采用逐步构造最优解的方法。在每个阶段，都作出一个看上去最优的决策（在一定的标准下）。决策一旦作出，就不可再更改。作出贪婪决策的依据称为贪婪准则（greedy criterion），也就是从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到某算法中的某一步不能再继续前进时，算法停止。

　　贪婪准则：（只取当前最优，不管整体）

　　　　① 贪婪准则设计算法过程每一步的最优解（局部最优）。

　　　　② 贪婪准则一旦设计好，中途不能改变。

　　注：贪婪算法最终并不一定能得到最优解。

　　了解了贪婪算法后，让我们尝试着用它来解决一些问题吧······

## 正文：

　　贪婪算法之装箱问题（也可叫背包问题，差不多啦，思想都一样）

　　1. 问题描述：

　　　　有若干个体积为V的箱子，现有N个物品，体积分别为：V0,V1,V2,V3,V4 ··· Vn-1（体积各不相同）。

　　　　要求：将所有物品都装入箱子中，使打开的箱子要尽可能的少。

　　2. 解决：（贪心准则）

　　　　A. 将所有物品按体积大小降序排列；

　　　　B. 每次取出一个物品（此物品必须是当前未装入箱子中体积最大的物品）；

　　　　C. 遍历所有已打开的箱子，将该物品放入一个较早打开的箱子，若都放不下，则再新打开一个箱子。

　　3. 存储：（不知箱子和物品的具体个数，所以选择使用链表，存储状态如下图）

<div align="center">
	<img src="/images/posts/tanXinSuanFa/01.png" height="400" width="600">  
</div>

　　4. 类型声明：

　　　　A. 存放物品信息的类型声明 

```
			typedef struct{
				int gno;	//物品编号
				int gv;		//物品体积 
			}ElemG;
```

　　　　   物品信息初始化

```
			for (int i=0;i<N;i++) {
				g[i].gno=i+1;
				scanf ("%d",&vol);
				g[i].gv=vol;
			}
```

<div align="center">
	<img src="/images/posts/tanXinSuanFa/02.png" height="220" width="900">  
</div>

　　　　B. 物品结点的类型

```
			typedef struct node {
				int gno;
				struct node *link;
			}Goodslink;
```　

　　　　C. 箱子结点的类型（假设箱子体积：#define V 50）

```
			typedef struct box {
				int remainder;	//箱子的剩余体积
				Goodslink *hg;	//指向物品结点的指针
				struct box *next;	//指向下一个结点的指针 
			}boxlink;
```

　　5.算法描述：

　　　　A. 创建物品信息数组并初始化

　　　　B. 把所有物品按体积降序排列

　　　　C. 装箱

　　　　D. 输出

　　6. 详细代码（C语言）

```
#include <stdio.h>
#include <stdlib.h>

#define V 50	//箱子体积定义 

//存放物品信息的类型声明 
typedef struct{
	int gno;	//物品编号
	int gv;		//物品体积 
}ElemG;

//物品结点类型声明
typedef struct node {
	int gno;
	struct node *link;
}Goodslink;

//箱子的结点类型
typedef struct box {
	int remainder;	//箱子的剩余体积
	Goodslink *hg;	//指向物品结点的指针
	struct box *next;	//指向下一个结点的指针 
}boxlink;

//全局定义一些变量 
ElemG *g;
int vol,N,k;
boxlink *hbox,*p,*tail;
Goodslink *q,*rear;

//子函数声明	
void initgoods(); 
void sort (); 
void encasement (); 
void print ();

//主函数 
int main (void) {
	printf ("请输入物品个数：");
	scanf ("%d",&N); 
	//开辟存物品的空间 
	g=(ElemG *) malloc (N * sizeof (ElemG)); 
	
	//初始化物品	
	initgoods(); 

	//降序排序 
	sort (); 
	
	//装箱
	encasement (); 
	
	//输出
	print (); 
}

/*
* 函数名：initgoods
* 功能：初始化物品 
* 参数：无
* 返回值：无 
*/
void initgoods(){
	for (int i=0;i<N;i++) {
		g[i].gno=i+1;
		printf ("请输入第%d个物品的体积：",i+1);
		scanf ("%d",&vol);
		//防止物品体积大于箱子体积,或者物品体积为负数 
		if ( vol > 0 && vol <= V ){
			g[i].gv=vol;
		}
		else {
			printf ("该物品体积超出范围，请重新输入！\n");
			i--;
		}
	}
}

/*
 * 函数名：sort
 * 功能：将所有物品按体积大小降序排序 
 * 参数：无
 * 返回值：无 
 */
void sort (){
	int i,j,t,tag=1;
	for (i=0;tag && i<N;i++){
		tag=0;
		for(j=0;j<N-i;j++)
			if (g[j].gv>g[j-1].gv)
			{
				t=g[j].gno;
				g[j].gno=g[j-1].gno;
				g[j-1].gno=t;
				
				t=g[j].gv;	
				g[j].gv=g[j-1].gv;
				g[j-1].gv=t;
				tag=1;
			}
	}
} 
/*
 * 函数名：encasement
 * 功能：将物品装入箱子 
 * 参数：无
 * 返回值：无 
 */
 void  encasement (){
 	//遍历所有的排序物品
	for (int i=0;i<N;i++){
		//遍历箱子链
		for (p=hbox;p && p->remainder <g[i].gv;p=p->next) {
			;
		}
		//如果没有箱子能放下，则开新箱子
		if (!p){
			//初始化箱子 
			p=(boxlink *) malloc (sizeof(boxlink));
			p->remainder=V;
			p->hg=NULL;
			p->next=NULL;
			//挂箱子
			if(!hbox)
				hbox=tail=p;
			else
				tail=tail->next=p; 
		}
		p->remainder=p->remainder-g[i].gv;	//减掉放入的空间 
		//放物品
		//创建物品结点 
		q=(Goodslink *) malloc (sizeof(Goodslink));
		q->gno=g[i].gno;
		q->link=NULL;
		//
		if (!p->hg)
			p->hg=q;
		else{
			for (rear=p->hg;rear->link;rear=rear->link)
				; //将rear指针跑到物品链尾部
			rear->link=q;	//挂物品 
		}
	}
 }
 
/*
* 函数名：print
* 功能：打印装箱情况 
* 参数：无
* 返回值：无 
*/	
void print () {
	for(k=1,p=hbox;p;p=p->next){
		printf ("第%d个箱子物品有：",k++);
		for (q=p->hg;q;q=q->link){
			printf("%d\t",q->gno);
		}
		printf ("\n");
	} 
}
```

## 寄语
　　
　　代码是死的人是活的，读者如果有更好的想法也可以私我，欢迎打扰~ 本文仅供参考。

<br>

转载请注明原地址：[豌豆恒的博客](http://www.wonderheng.top) » [点击阅读原文](http://henghengCSDN.github.io/2017/12/浅谈排序-快速排序/)谢谢！

