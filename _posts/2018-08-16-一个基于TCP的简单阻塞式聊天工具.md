---
layout: post
title: ⼀个基于TCP的简单阻塞式网络聊天⼯具
date: 2018-08-17
tag: Linux 
--- 

# 服务器-(TCPServer.c)

```C
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <sys/types.h>
#include <string.h>
#include <unistd.h>

#define _PORT_ 9999
#define _BACKLOG_ 10 

int main(){
        int sock = socket(AF_INET,SOCK_STREAM,0);
        if(sock < 0){
                printf("create socket error , error is : %d,errstring is : %s\n",errno,strerror(errno));
        }
        struct sockaddr_in server_socket;
        struct sockaddr_in client_socket;

        bzero(&server_socket,sizeof(server_socket));
        server_socket.sin_family = AF_INET;
        server_socket.sin_addr.s_addr=htonl(INADDR_ANY);
        server_socket.sin_port=htons(_PORT_);

        if(bind(sock,(struct sockaddr *)&server_socket,sizeof(struct sockaddr_in))<0){
                printf("create socket error , error is : %d,errstring is : %s\n",errno,strerror(errno));
                close(sock);
                return 1;
        }
        if(listen(sock,_BACKLOG_)<0){
                printf("create socket error , error is : %d,errstring is : %s\n",errno,strerror(errno));
                close(sock);
                return 2;
        }
        printf("bind and listen success , wait accept···\n");

        for(;;){
                socklen_t len = 0;
                int client_sock = accept(sock,(struct sockaddr *)&client_socket,&len);
                if(client_sock < 0){
                        printf("create socket error , error is : %d,errstring is : %s\n",errno,strerror(errno));
                        close(sock);
                        return 3;
                }
                char buf_ip[INET_ADDRSTRLEN];
                memset(buf_ip,'\0',sizeof(buf_ip));
                inet_ntop(AF_INET,&client_socket.sin_addr,buf_ip,sizeof(buf_ip));

                printf("get connet , ip is : %s , port is : %d\n",buf_ip,ntohs(client_socket.sin_port));
                while(1){
                        char buf[1024];
                        memset(buf,'\0',sizeof(buf));

                        read(client_sock,buf,sizeof(buf));
                        printf("client :# %s\n",buf);
                        printf("server :$ ");
                        memset(buf,'\0',sizeof(buf));
                        fgets(buf,sizeof(buf),stdin);
                        buf[strlen(buf)-1] = '\0';
                        write (client_sock,buf,strlen(buf)+1);
                        printf("please wait···\n");

                }
        }
        close(sock);
        return 0;
}
```

# 客户端-(TCPClient.c)

```C
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <sys/types.h>
#include <strings.h>
#include <unistd.h>

#define SERVER_PORT 9999
#define SERVER_IP "192.168.43.144" 

int main(int argc,char *argv[]){
        if(argc != 2){
                printf("Usage : client IP\n");
                return 1;
        }
        char * str=argv[1];
        char buf[1024];
        memset(buf,'\0',sizeof(buf));

        struct sockaddr_in server_sock;
        int sock = socket(AF_INET,SOCK_STREAM,0);
        bzero(&server_sock,sizeof(server_sock));
        server_sock.sin_family = AF_INET;
        inet_pton(AF_INET,SERVER_IP,&server_sock.sin_addr);
        server_sock.sin_port = htons(SERVER_PORT);

        int ret = connect (sock,(struct sockaddr *)&server_sock,sizeof(server_sock));
        if(ret<0){
                printf("connect failed...,errno is : %d,errstring is: %s\n",errno,strerror(errno));
                return 1;
        }
        printf("connect success...\n");
        while(1){
                printf("client :# ");
                fgets(buf,sizeof(buf),stdin);
                buf[strlen(buf)-1]='\0';
                write(sock,buf,sizeof(buf));
                if(strncasecmp(buf,"quit",4)==0){
                        printf("quit!\n");
                        break;
                }
                printf("please wait...\n");
                read(sock,buf,sizeof(buf));
                printf("server :$ %s\n",buf);
        }
        close(sock);
        return 0;
}

```

# 寄语

* 在Linux环境分别编译服务器和客户端程序

> [root@localhost TCP]# `gcc -o TCPServer TCPServer.c`<br>
> [root@localhost TCP]# `gcc -o TCPClient TCPClient.c`

<div align="center">
	<img src="/images/posts/TCPliaotian/1.png" height="44" width="444">  
</div>
<br>
<br>
<br>

* 先运行服务器，再运行客户端
	
1.运行服务器 -> `./TCPServer`

<div align="center">
	<img src="/images/posts/TCPliaotian/2.png" height="40" width="413">  
</div>
<br>
<br>

2.运行客户端 -> `./TCPClient 服务器ip`

<div align="center">
	<img src="/images/posts/TCPliaotian/3.png" height="41" width="454">  
</div>
<br>
<br>

**注：若不知道服务器ip，可通过 `ifconfig` 命令查看服务器ip**

<div align="center">
	<img src="/images/posts/TCPliaotian/5.png" height="380" width="755">  
</div>
<br>
<br>

3.连接成功后，服务器会返回客户端ip...

<div align="center">
	<img src="/images/posts/TCPliaotian/4.png" height="81" width="476">  
</div>

<br>
<br>

4.然后即可进行阻塞式聊天

<div align="center">
	<img src="/images/posts/TCPliaotian/4.png" height="246" width="882">  
</div>

<br>

转载请注明原地址：[wonderheng的博客](http://www.wonderheng.top) » [点击阅读原文](http://henghengCSDN.github.io/2018/08/一个基于TCP的简单阻塞式聊天工具/)谢谢！
