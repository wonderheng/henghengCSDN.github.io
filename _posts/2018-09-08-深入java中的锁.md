---
layout: post
title: 深入java中的"锁"
date: 2018-09-08
tag: javaSE学习心得
---

### 1. CAS：Compare And Swap-乐观锁

* 悲观锁(JDK1.6之前的内建锁)：假设每一次执行同步代码块均会产生冲突，所以当线程获取成功，会阻塞其他尝试获取该锁的线程。

* 乐观锁(Lock)：假设所有线程访问共享资源时，不会出现冲突，则不会阻塞其他线程，因此不会出现线程阻塞状态。

* CAS(无锁操作)，使用CAS叫做比较交换来判断是否产生冲突，出现冲突就重试当前操作，直到不冲突为止。

### 2. CAS操作过程

* 一般来说，CAS比较交换可理解为(V,O,N)：
  * V：内存地址存放的实际值
  * O：预期值(旧值)
  * N：更新后的值

* 当执行CAS后，如果`V==0`，即旧值与内存中的实际值相等，表示上次修改的值没有任何线程再次修改此值，因此可以将N替换到内存中。
* 如果`V!=0`，表示该内存中的值已经被其他线程做了修改，所以无法将N替换，返回最新的值V。
* 当多个线程使用CAS操作同一个变量时，只有一个线程会成功，并成功更新变量值，其他线程均会失败，失败线程会重新尝试或将线程挂起。

### 3. 元老级内建锁(synchronized)问题：

* 当线程存在竞争的情况下会出现线程阻塞以及唤醒带来的性能问题，对应互斥同步(阻塞同步)，效率很低。
* 而CAS并不是武断的将线程挂起，会尝试若干次CAS操作，并非进行耗时的挂起与唤醒操作，因此非阻塞式同步。

### 4. CAS问题

* ABA问题：
  * **解决思路：沿用数据库的乐观锁机制，添加版本号`1A-2B-3A`。**
  * JDK1.5提供`atomic`包下`AtomicStampedReference`类来解决CAS的ABA问题。
* 自旋(CAS)会浪费大量的处理器资源
  * 与线程阻塞相比，自旋会浪费大量的CPU资源，因为此时线程仍处于运行状态，只不过跑的是误用指令，期望在无用指令时，锁能被释放出来。
  * **解决思路：自适应自旋，根据以往自旋等待时能否获取到锁，来动态的调整自旋的时间(循环尝试的数量)。**
    * 如果上一次自旋时获取到锁，则此次自旋的时间稍微变长一点；
    * 如果在上一次自旋结束还没获取到锁，此时自旋时间稍微短一点。
* 公平性
  * 处于阻塞状态的线程无法立刻竞争被释放的锁；而处于自旋状态的线程很有可能先获取到锁。
  * 内建锁无法实现公平性。
  * lock体系可以实现公平锁。

### 5. java对象头

* JDK1.6之后对内建锁做了优化(新增偏向锁、轻量级锁)

  |  锁类别  | 锁标志位 |
  | :------: | :------: |
  |   无锁   |   0 01   |
  |  偏向锁  |   1 01   |
  | 轻量级锁 |    00    |
  | 重量级锁 |    10    |

  * 以上这四种状态随着竞争情况的逐渐升级，锁可以不断升级，但不能降级，为了提高获得锁与释放锁的效率。

### 6. 偏向锁

* 偏向锁：最乐观的锁，从始至终**只有一个线程**请求一把锁。
* **偏向锁获取**：
  * 当一个线程访问同步代码块并获取时，会在对象头和栈帧中的锁记录中记录存储偏向锁的线程ID；以后该线程再次进入同步块时，不在需要CAS来加锁和解锁，只需要简单测试一下对象头的mark  word中偏向锁线程ID是否是当前线程ID：
    * 如果成功，表示线程已经获取到锁进入代码块中运行。
    * 如果测试失败，检查当前偏向锁字段是否为0：
      * 如果为0，采用CAS操作将偏向锁字段设置为1，并且更新自己的线程ID到mark word 字段中。
      * 如果为1，表示此时偏向锁已经被别的线程获取，则此线程不断尝试使用**CAS获取偏向锁**或者将**偏向锁撤销，升级为轻量级锁(升级概率较大)**。
* **偏向锁撤销**：
  * 偏向锁使用一种等待竞争出现才释放锁的机制，当有其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁。
* 注意：
  * 偏向锁的撤销开销较大，需要等待进入**全局安全点`safepoint`**(当前线程在CPU上没有执行任何有用字节码)
  * 偏向锁从JDK1.6开始默认启用，但是他在应用程序启动几秒后才激活。
    * `-XX:BiasedLockingStartupDelay=0`，将延迟关闭，JVM一启动就激活偏向锁。
    * `-XX:-UseBiasedLocking=false`，关闭偏向锁，程序默认进入轻量级锁。

### 7. 轻量级锁

* 轻量级锁：**多个线程**在不同时间段请求同一把锁，也就是基本不存在锁竞争。针对此种状况，JVM采用轻量级锁来避免线程的阻塞以及唤醒。
* **轻量级锁加锁**：线程执行同步代码块之前，JVM先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的mark word字段直接复制到此空间中，然后线程尝试使用CAS将对象头的mark word替换为指向锁记录的指针(指向当前线程)：
  * 如果成功，表示获取到轻量级锁；
  * 如果失败，则表示其他线程竞争轻量级锁，当前线程便使用自旋来不断尝试获取锁。
* **轻量级锁释放**：解锁时，会将CAS将复制的`mark word`替换会对象头：
  * 如果成功，表示没有竞争发生，正常解锁；
  * 如果失败，表示当前锁存在竞争，进一步膨胀为**重量级锁**。

### 8. 总结

* 重量级锁：会阻塞、唤醒请求加锁的线程。针对的是多个线程同一时刻竞争同一把锁的情况，JVM采用自适应自旋，来避免线程在面对非常小的同步块时，仍会被阻塞以及唤醒。
* 轻量级锁采用的是CAS操作，将锁对象的标记字段替换为指向线程的指针，存储着锁对象原本的标记字段。针对的是多个线程在不同时间段申请同一把锁的情况。
* 偏向锁只会在第一次请求是采用CAS操作，在锁对象的mark word字段中记录下当前线程ID，此后运行中持有偏向锁的线程不在有加锁过程。针对的是锁仅被同一线程持有。



<br>

转载请注明原地址：[wonderheng的博客](http://www.wonderheng.top) » [点击阅读原文](http://www.wonderheng.top/2018/09/深入java中的锁/),谢谢！







