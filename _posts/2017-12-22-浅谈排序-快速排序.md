---
layout: post
title: 浅谈排序--快速排序（最常用）
date: 2017-12-22
tag: 算法 
---   

<div align="center">
	<img src="/images/posts/quickSort/xiaozhangyu.gif" height="300" width="500">  
</div>

## 前言：

　　程序员考试过了，哈哈， 🔥 🔥 🔥 虽然不是什么很大的荣耀，但它也算是我“软件之路”的起点吧;回想起那段“痛苦”的学习经历，这个消息还是能带给自己一些慰藉的。好了，说正事。上次说的冒泡排序算是第一个真正的排序算法，它解决了桶排序的空间浪费问题，而且应用面更广了;但是从算法的执行效率来讲，它的劣势就显而易见了，对一亿个数进行排序，桶排序只需要0.1秒，它却需要1000万秒，达到115天之久，是不是很吓人？那么有没有一个既不浪费空间又相对来说快一点的算法呢？答案是肯定的，今天就给大家分享另一个排序算法--快速排序······
　　读者有什么问题可以加我 ＱＱ：995107866　，或者给我发邮件：[995107866@qq.com](mailto:995107866@qq.com)。

## 正文：

　　假设我们要对 `6 1 2 7 9 3 4 5 10 8` 这10个数进行排序。我们得到了下图这样的数组：

```
  6    1    2    7    9    3    4    5    10   8 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]
```
       
　　首先我们需要在这个序列中随便找一个数作为基准数（就是一个作为参照的数），这里为了方便，我就让就让第一个数6作为基准数吧，接下来我们的目标就是要把比基准数小的数都放到基准数的左边，比基准数大的都放在它的右边。然而初始状态下，数字6在序列的第一位，我们的目标是将6移到中间的某个位置（分界点），假定为k（即k左边的小于6，右边的都大于6）。类似下面这种排列:

```
  3    1    2    5    4    `6`    9    7    10   8 
a[0] a[1] a[2] a[3] a[4] `a[5]` a[6] a[7] a[8] a[9]
```

　　很明显，这里肯定要用到移动数据了，如何实现呢？回忆一下冒泡排序时我们交换数据的方法，其实很简单，我们从数据的两侧进行"探测"，先从右往左找到一个小于6的数，再从左往右找到一个大于6的数（因为我们的基准数设的是最左边的数，所以要先从右往左。自己先想想为什么），然后把它们交换，这里我们需要定义两个“哨兵” i和j，刚开始哨兵i指向数字6（即i=0，a[i]的值），哨兵j指向8（最后一个数）。如图:

```
  i                                            j
  ↓                                            ↓
  6    1    2    7    9    3    4    5    10   8 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]

```

　　现在先让哨兵j出动，j一步步向左挪动（即j--），直到找到一个小于6的数菜停下来。接下来再让哨兵i一步步向右挪动（即i++），所以第一次哨兵j会停在数字5上，哨兵i则会停在数字7上。如下图：

```
                 i                   j          
                 ↓                   ↓          
  6    1    2    7    9    3    4    5    10   8 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]
```
然后交换他们（即交换此时的a[i]和a[j]，注意不是交换i和j），交换后变为：
```
                 i                   j          
                 ↓                   ↓  
  6    1    2    5    9    3    4    7    10   8 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]
```

　　到此，第一次交换结束。接下来哨兵j继续向左挪动（每次必须是j先移动），如上述情况可知，j会停在数字4的上面;同理，i向右挪动，会停在数字9的上面。如图：

```
                      i         j          
                      ↓         ↓          
  6    1    2    5    9    3    4    7    10   8 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]
```
然后交换他们，交换后变为：
```
                      i         j          
                      ↓         ↓          
  6    1    2    5    4    3    9    7    10   8 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]
```

　　第二次交换结束，“探测”继续，哨兵j继续想左移动，不难看出，它会停在数字3的上面（3比6小），然后i继续向右移动，此时我们发现哨兵i和哨兵j“相遇”了，他们都走到了数字3的上面，如下图：

```
                           j 
                           i          
                           ↓            
  6    1    2    5    4    3    9    7    10   8 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]
```

别急，此刻我们就认为“探测”结束了，这个时候只需要把我们的基准数和i和j此时同时指向的数字交换即可，交换后的结果为：

```
                           j 
                           i          
                           ↓            
  3    1    2    5    4    6    9    7    10   8 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]
```

　　到此，第一轮“探测”就真正结束了。此时以数字6为分界点，可以看出，6左边的数都比6小，6右边的数都比6大。回顾一下上述的过程，其实哨兵j的使命就是找到比基准数小的数，哨兵i的使命就是找到比基准数大的数，直到i和j“碰头”为止。
　　OK，解释完毕，现在基准数6已经归位，它正好处于序列的第六位，此时，我们就可以将原来的序列，以6位分界点拆分成两个子序列，左边的子序列为“ 3 1 2 5 4 ”，右边的子序列为“ 9 7 10 8 ”。接下来还需要分别处理这两个子序列，因为他们的顺序还是乱的。不过不要紧，我们已经掌握了处理方法，现在只需要用刚才的方法分别处理两个子序列即可，过程这里就不再重复写了，可以自己模拟一下，如果你处理的没错，处理完正确的顺序应该是：

```
            j 
            i          
            ↓            
  2    1    3    5    4
a[0] a[1] a[2] a[3] a[4]
```

　　好，现在3也已经归位，接下来再以3为分界点，再将此时的序列分为两个子序列“ 2 1 ”和“ 5 4 ”，对序列“ 2 1 ”以2为基准点，再次处理（设i,j;j指向2，i指向1;然后看看j是不是比2小，是就停下，不是就挪动，i和j碰头就停······方法还是和上面一样，忍不住又简述了一遍），处理完毕的顺序应该是“ 1 2 ”，到此2也就归位了，序列1就一个数，不用处理。而序列“ 5 4 ”用同样的方法处理，处理完后左边的序列就全部处理完毕了，此时序列就应该为：

```            
  1    2    3    4    5    6    9    7    10   8 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]
```

　　对于右边的子序列“ 9 7 10 8 ”，采用同样的方法，直到不能拆分出新的子序列为止。最终我们就可以得到这样的序列：

```            
  1    2    3    4    5    6    7    8    9   10 
a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9]
```

　　到此，排序就完全结束了。细心的人会发现，快排的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。还是老规矩，上代码先：

```
#include <stdio.h>
int a[101],N; //定义全局变量，这两个变量需要在子函数中使用 

void quick_sort(int left,int right)
{	 
	int i,j,t,temp;
	if(left>right)
		return;
	temp=a[left];	//temp存储基准数
	i=left;
	j=right;
	while (i!=j)
	{
		//此处顺序很重要，必须先从右向左找 
		while(a[j]>=temp && i<j)
			j--;
		//再从左向右找	
		while(a[i]<=temp && i<j)
			i++;
		//交换两个数再数组中的位置 
		if (i<j)	//当哨兵i和哨兵j未相遇时 
		{
			t=a[i];
			a[i]=a[j];
			a[j]=t;
		} 
	}
	a[left]=a[i];	//基准位归位，即放中间
	a[i]=temp;
	//递归继续排左右两边的子序列 
	quick_sort(left,i-1);	//左边子序列 
	quick_sort(i+1,right);	//右边子序列 
	return; 
}

int main ()	//主函数
{
	int i;
	//录入数据
	scanf ("%d",&N);
	for (i=0;i<N;i++)
		scanf ("%d",&a[i]);
		
	quick_sort(0,N-1); //调用快排子函数
	//输出结果
	for (i=0;i<N;i++)
		printf ("%d ",a[i]);
	return 0; 
} 

输入数据：
　　　　　10
　　　　　6 1 2 7 9 3 4 5 10 8
输出结果：
　　　　　1 2 3 4 5 6 7 8 9 10

```

### 寄语
　　
快速排序之所以比较快，是因为相比冒泡排序，每次交换都是跳跃式的。每次排序的时候，设置一个基准点，将小于等于基准点的数全部放在基准点的左边，将大于等于基准点的数全部放在基准点的右边，这样每次交换就不会想冒泡排序一般只能在相邻的数间进行交换，交换距离就大得多了。因此，总的比较和和交换次数就少了，速度自然提升。但是最坏的情况下，快排仍然可能是相邻的两个数进行交换，所以，快排的最差时间复杂度和冒泡排序是一样的，都为 O(N²)，但快排的平均时间复杂度为 O(NlogN)。其实，快速排序是基于一种叫做“二分”的思想。以后有机会咱们再聊吧······
<br>

<div align="center">
	<img src="/images/posts/quickSort/thanks.gif" height="300" width="500">  
</div>

转载请注明原地址：[豌豆恒的博客](http://www.wonderheng.top) » [点击阅读原文](http://henghengCSDN.github.io/2017/12/浅谈排序-快速排序/)谢谢！

