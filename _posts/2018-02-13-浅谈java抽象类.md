---
layout: post
title: 浅谈java抽象类
date: 2018-02-13

tag: javaSE学习心得
--- 


### 1. 抽象类的产生 
* a: 分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。

### 2. 抽象类的定义格式 

* a: 格式
  * `public abstract 返回值类型 方法名(参数);`
  * 例：
```java
	abstract class 类名 {
		
	}
```

* c: 抽象类示例代码：

```java
	/*
	 *  定义类开发工程师类
	 *    EE开发工程师 :  工作
	 *    Android开发工程师 : 工作
	 *    
	 *    根据共性进行抽取,然后形成一个父类Develop
	 *    定义方法,工作: 怎么工作,具体干什么呀
	 *    
	 *    抽象类,不能实例化对象, 不能new的
	 *    不能创建对象的原因:  如果真的让你new了, 对象.调用抽象方法,抽象方法没有主体,根本就不能运行
	 *    抽象类使用: 定义类继承抽象类,将抽象方法进行重写,创建子类的对象
	 */
	public abstract class Develop {
	   //定义方法工作方法,但是怎么工作,说不清楚了,讲不明白
		//就不说, 方法没有主体的方法,必须使用关键字abstract修饰
		//抽象的方法,必须存在于抽象的类中,类也必须用abstract修饰
		public abstract void work();
	}
```

### 3. 抽象类的使用
* A:抽象类的使用方式

```java
/*
*  定义类,JavaEE的开发人员
*  继承抽象类Develop,重写抽象的方法
*/
public class JavaEE extends Develop{
	//重写父类的抽象方法
	//去掉abstract修饰符,加上方法主体
	public void work(){
		System.out.println("JavaEE工程师在开发B/S 软件");
	
	}
}
/*
 *  定义Android类,继承开发人员类
 *  重写抽象方法
 */
public class Android extends Develop{
     public void work(){
    	 System.out.println("Android工程师开发手机软件");
     }
}

/*
 *  测试抽象类
 *    创建他的子类的对象,使用子类的对象调用方法
 */
public class Test {
	public static void main(String[] args) {
		 JavaEE ee = new JavaEE();
		 ee.work();//"JavaEE工程师在开发B/S 软件"
		 
		 Android and = new Android();
		 and.work();//"Android工程师开发手机软件"
	}
}
```

### 4. 抽象类特点
* **所有抽象类必须有子类**。
* **抽象类的子类必须覆写抽象类的所有抽象方法。**
* **抽象类无法直接创建实例化对象，需要通过子类向上转型为其实例化。**

```java
abstract class A{
	public abstract void func();
	public abstract void func2();
}
class A2 extends A{//A2把A中的两个抽象方法都重写掉了
	                 //A2类不再是抽象类
	 public void func(){}
	 public void func2(){}
}

abstract class A3 extends A{//含有抽象方法的类一定是抽象类
	 public void func(){

	 }
	 //public abstract void func2();//func2相当于被继承下来
}
```

### 5. 抽象类的设计思想
* A:抽象类的设计思想
  * a:抽象类的作用:继承的体系抽象类,强制子类重写抽象的方法
```
    抽象员工:
      规定一个方法,work工作
      EE员工,Android员工 
       
       Develop类 抽象类
       abstract work();
           |
    -------------
  |             |
  EE            Android  
  work(){}       work(){}
```

### 6. 抽象类细节
* a:抽象类一定是个父类,因为不断抽取而来的。
* b:抽象类中可以不定义抽象方法,不让该类创建对象,方法可以直接让子类去使用
* c:(适配器设计模式)

```java
/*
 *   抽象类,可以没有抽象方法,可以定义带有方法体的方法
 *   让子类继承后,可以直接使用
 */
public  abstract class Animal {
     public void sleep(){
    	 System.out.println("动物睡觉");
     }
    
}
public class Cat extends Animal{

}     

public class Test {
	public static void main(String[] args) {
		//Cat c = new Cat();
		new Cat().sleep();//不让该类创建对象,方法可以直接让子类去使用
	}
}
```

* d:抽象关键字abstract不可以和哪些关键字共存？	
		* :private：私有的方法子类是无法继承到的，也不存在覆盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法,而private修饰子类根本无法得到父类这个方法。互相矛盾。 

```java
    /*
	 *   抽象类,可以没有抽象方法,可以定义带有方法体的方法
	 *   让子类继承后,可以直接使用
	 */
	public  abstract class Animal {
	 
	     // private abstract void show();
	     //抽象方法,需要子类重写, 如果父类方法是私有的,子类继承不了,也就没有了重写
	}
```



### 7. 员工案例分析
* A:员工案例分析:
 * a:需求描述:
	* 某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。
	* 研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；
	* 维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。
	* 公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。
	* 工作内容:
		* JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站
		* Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件
		* 网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通
		* 硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机
 * b:继承体系:

```
                    员工
                     |
   --------------------------------------------
   |                                          |
 研发部员工                                 维护部员工
   |                                          |
-------------                              -----------
|            |                             |         |
JavaEE工程师   Android工程师         网络维护工程师    硬件维护工程师
```

 * c:详细描述:
	* 根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。则，把这些共同的属性与功能抽取到父类中（员工类），关于工作的内容由具体的工程师来进行指定。

### 8. 员工案例Employee类
* 员工案例Employee类的编写:按照分析的继承体系来逐个实现

```java
 /*
 *  定义员工类
 *    内容,都是所有子类的共性抽取
 *      属性: 姓名,工号
 *      方法: 工作
 */
public abstract class Employee {
	private String id;// 员工编号
	private String name; // 员工姓名

	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	//工作方法（抽象方法）
	public abstract void work(); 
}
```

### 9. 员工案例的子类
* 员工案例的子类的编写:

```java
 /*
 *  定义研发员工类
 *    属于员工中的一种, 继承员工类 
 *    抽象类Develop 给自己的员工定义自己有的属性
 */
public abstract class Develop extends Employee{

}

/*
 *  描述JavaEE开发工程师类
 *    工号,姓名 工作方法
 *  其他的员工,也具备这些共性,抽取到父类中,自己就不需要定义了
 *  是研发部员工的一种,继承研发部类
 */
public class JavaEE extends Develop{
	//重写他父类的父类的抽象方法
	public void work(){
		//调用父类的get方法,获取name,id值
		System.out.println("JavaEE的工程师开发淘宝"+ super.getName()+".."+super.getId());
	}
}
/*
*定义Android工程师 继承 研发部员工类，重写工作方法
*/
public class Android extends Developer {
  @Override
   public void work() {
	System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在研发淘宝手机客户端软件");
  }
}


/*
 *   定义维护员工类,属于员工中的一种
 *   继承员工类
 *   抽象类Maintainer 给自己的员工定义自己有的属性
 */
public abstract class Maintainer extends Employee{

}

/*
 *  描述的是网络维护工程师
 *  属于维护部的员工,继承维护部类
 */
public class Network extends Maintainer{
	public void work(){
		System.out.println("网络工程师在检查网络是否畅通"+super.getName()+"..."+super.getId());
	}
}

/*
 *定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法
 */
public class Hardware extends Maintainer {
	@Override
	public void work() {
		System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在修复打印机");
	}
}
```

<br>

转载请注明原地址：[wonderheng的博客](http://www.wonderheng.top) » [点击阅读原文](http://www.wonderheng.top/2018/02/%E6%B5%85%E8%B0%88java%E6%8A%BD%E8%B1%A1%E7%B1%BB/),谢谢！