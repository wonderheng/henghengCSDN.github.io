---
layout: post
title: 引用、垃圾回收器与内存分配策略
date: 2018-08-21
tag: JVM 
--- 

### **1. 判断对象无用（对象已死）的算法**
* a.引用计数法（Pathon、js、C++智能指针等语言应用此算法）
	* 给每个对象附加一个引用计数器，每当有一个地方引用此对象时，计数器+1，引用失效时计数器-1，任何时刻计数器为0的对象就是不能再被使用的对象，即对象已死
	* 优点：实现简单，判定效率高，大部分场景下都是不错的算法
	* 缺点：无法解决循环引用问题

* b.可达性分析算法：Java采用
	* 通过一系列称为GC Roots的对象作为起点开始向下搜索，直到找到此对象，搜索走过的路径称为“引用链”。
	* 当一个对象到GC Roots没有任何引用链时（到GC Roots对象不可达），证明此对象已死。
	* 在Java语言中，GC Roots语言对象包含以下几种：
		* 1.局部变量表中引用的对象
		* 2.本地方法栈中引用的对象
		* 3.方法区中常量、静态属性引用的对象
	* 图示：
<div align="center">
	<img src="/images/posts/2018-08-21/1.png" height="300" width="500">  
</div>

### **2. JDK1.2后对引用概念的扩充（强>软>弱>虚）**

* a.强引用（Strong Reference）：强引用指的是在代码中普遍存在的，类似Object obj=new Object（）这类的引用。只要强引用还存在，垃圾回收器永远不会回收掉被引用对象实例（即便发生OOM）

* b.软引用（Soft Reference）：软引用主要描述一些有用但不必须对象，对于只有软引用关联的对象，在系统即将发生内存溢出之前，会把软引用对象列入回收范围，进行第二次垃圾回收，如果此次GC后还是没有足够内存，才会抛出OOM。JDK1.2之后提供有SoftReference类来实现软引用

* 3.弱引用（Weak Reference）：弱引用也是描述非必须对象，强度弱于软引用，基本弱引用关联的对象只能生存到下一次垃圾回收之前。当GC开始时，无论当前内存是否够用，都会回收掉只被弱引用关联的对象，WeakReference实现弱引用

* 4.虚引用（Phantom Reference）：也被称为幽灵引用，或者幻影引用。一个对象是否有虚引用的存在，完全不对其生存时间构成影响，也无法通过虚引用取得对象实例。为一个对象设置虚引用的唯一目的是：此对象在被垃圾回收时收到一个系统通知

### **3. 对象被标记为无用对象后的生命周期**
* A.`protect void finalize（）throws Throwable{}`： 缓刑阶段
* B.一个对象彻底死亡至少要经历两次标记过程：
	* a.阶段1:如果对象到任意一个`GC Roots`对象不可达，它将被第一次标记并且进行一次筛选。筛选的依据为：对象是否要执行`finalize()`方法，当对象没有覆写`finalize`方法时或者`finalize`方法被调用过，此时对象真正死亡
	* b.如果对象覆写`finalize`方法，且未被JVM调用，此对象会被放置在`F-Queue`队列中，稍后被JVM回调`finalize()`。如果对象在`finalize()`中又和`GC Roots`相连，则成功拯救自己，否则真正死亡。
	* c.一个对象的finalize方法只会被JVM调用一次，JVM主动地回调，如果人为调用，将会被视为普通方法

### **4. 回收方法区：主要回收废弃常量与无用类**
* 判断一个类为无用类的要求：
	* a.该类的所有实例已经被回收（Java堆中不存在任何该类的实例）
	* b.加载此类的类加载器已被回收
	* c.该类对应的Class对象没有在其他任何对方引用，无法通过反射访问该类的所有属性与方法

### **5. 垃圾回收器（JDK1.8）-垃圾回收算法的具体实现**
* 新生代垃圾回收器：Serial（串行）、ParNew（并行）、Parallel Scavenge（并发）
* 老年代垃圾回收器：CMS（并发）、SerialOld（串行）、Parallel Old（并发）
* 全区域垃圾收集器：G1（并发）
* 图示：
<div align="center">
	<img src="/images/posts/2018-08-21/2.png" height="300" width="500">  
</div>

### **6. 几个概念**
* 并行：多条垃圾回收线程并行工作，而用户线程仍然等待
* 并发：指用户线程与垃圾回收线程同时执行，
* 吞吐量：CPU运行用户代码时间/CPU总时间（用户代码时间+GC时间）
* STW:垃圾回收线程工作时，所有工作线程暂停直到垃圾回收线程工作结束


### **7. 内存回收与分配策略**
* 1.对象优先在Eden分配：大多数情况下，对象优先在新生代Eden分配，当Eden区没有足够空间进行分配时，JVM将发生一次Minor GC

* 2.大对象直接进入老年代：
	* `-XXPreTenureSizethreshold` **大于** 此参数的对象直接在老年代分配

* 3.长期存活对象进入老年代
	* 当对象从 Eden 区移动到 Survivor 时，年龄为1，每当对象在from-to复制一次，age+1；
	* `-XX：MaxTenuringThreshold=10` （年龄为10时，移入老年代，不设置此参数默认年龄为15）

* 4.动态的对象年龄判定（优先级较高）
	* 如果在Survivor空间中相同年龄的所有对象大小的总和 **大于** Survivor空间的一半，年龄**大于等于**该年龄的对象直接进入老年代，无需等到`MaxTenuringThreshold`规定的年龄

### **补充-区别内存泄漏和内存溢出**
* 内存泄漏：泄漏对象无法被GC（无论内存调整为多大仍然无法被GC）
* 内存溢出：对象确实还应该存活（还有事情要做），此时应该调整JVM参数适当加大堆内存或者检查对象声明周期是否过长

<br>

转载请注明原地址：[wonderheng的博客](http://www.wonderheng.top) » [点击阅读原文](http://www.wonderheng.top/2018/08/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/)，谢谢！